

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>EMEPy Complete User Library &mdash; EMEpy 2.0 documentation</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="EMEPy Examples" href="examples.html" />
    <link rel="prev" title="EMEpy" href="index.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home" alt="Documentation Home"> EMEpy
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">EMEPy Complete User Library</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#mode">Mode</a></li>
<li class="toctree-l2"><a class="reference internal" href="#eme">EME</a></li>
<li class="toctree-l2"><a class="reference internal" href="#modesolver">ModeSolver</a></li>
<li class="toctree-l2"><a class="reference internal" href="#monitors">Monitors</a></li>
<li class="toctree-l2"><a class="reference internal" href="#neural-network-acceleration">Neural Network Acceleration</a></li>
<li class="toctree-l2"><a class="reference internal" href="#tools">Tools</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="examples.html">EMEPy Examples</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">EMEpy</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>EMEPy Complete User Library</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/library.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="emepy-complete-user-library">
<h1>EMEPy Complete User Library<a class="headerlink" href="#emepy-complete-user-library" title="Permalink to this headline">¶</a></h1>
<div class="section" id="mode">
<h2>Mode<a class="headerlink" href="#mode" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="emepy.mode.Mode">
<em class="property">class </em><code class="sig-prename descclassname">emepy.mode.</code><code class="sig-name descname">Mode</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">y</span></em>, <em class="sig-param"><span class="n">wl</span></em>, <em class="sig-param"><span class="n">neff</span></em>, <em class="sig-param"><span class="n">Hx</span></em>, <em class="sig-param"><span class="n">Hy</span></em>, <em class="sig-param"><span class="n">Hz</span></em>, <em class="sig-param"><span class="n">Ex</span></em>, <em class="sig-param"><span class="n">Ey</span></em>, <em class="sig-param"><span class="n">Ez</span></em>, <em class="sig-param"><span class="n">n</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">width</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">thickness</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#emepy.mode.Mode" title="Permalink to this definition">¶</a></dt>
<dd><p>Object that holds the field profiles and effective index for an eigenmode</p>
<dl class="py method">
<dt id="emepy.mode.Mode.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">y</span></em>, <em class="sig-param"><span class="n">wl</span></em>, <em class="sig-param"><span class="n">neff</span></em>, <em class="sig-param"><span class="n">Hx</span></em>, <em class="sig-param"><span class="n">Hy</span></em>, <em class="sig-param"><span class="n">Hz</span></em>, <em class="sig-param"><span class="n">Ex</span></em>, <em class="sig-param"><span class="n">Ey</span></em>, <em class="sig-param"><span class="n">Ez</span></em>, <em class="sig-param"><span class="n">n</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">width</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">thickness</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#emepy.mode.Mode.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructor for Mode Object</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>(</em><em>ndarray float</em><em>)</em>) – array of grid points in x direction (propogation in z)</p></li>
<li><p><strong>y</strong> (<em>(</em><em>ndarray float</em><em>)</em>) – array of grid points in y direction (propogation in z)</p></li>
<li><p><strong>wl</strong> (<em>(</em><em>float</em><em>)</em>) – wavelength (meters)</p></li>
<li><p><strong>neff</strong> (<em>(</em><em>float</em><em>)</em>) – effective index</p></li>
<li><p><strong>Hx</strong> (<em>(</em><em>ndarray float</em><em>)</em>) – Hx field profile</p></li>
<li><p><strong>Hy</strong> (<em>(</em><em>ndarray float</em><em>)</em>) – Hy field profile</p></li>
<li><p><strong>Hz</strong> (<em>(</em><em>ndarray float</em><em>)</em>) – Hz field profile</p></li>
<li><p><strong>Ex</strong> (<em>(</em><em>ndarray float</em><em>)</em>) – Ex field profile</p></li>
<li><p><strong>Ey</strong> (<em>(</em><em>ndarray float</em><em>)</em>) – Ey field profile</p></li>
<li><p><strong>Ez</strong> (<em>(</em><em>ndarray float</em><em>)</em>) – Ez field profile</p></li>
<li><p><strong>width</strong> (<em>number</em>) – The core width</p></li>
<li><p><strong>thickness</strong> (<em>number</em>) – The core thickness</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="emepy.mode.Mode.compute_other_fields">
<code class="sig-name descname">compute_other_fields</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#emepy.mode.Mode.compute_other_fields" title="Permalink to this definition">¶</a></dt>
<dd><p>Given the Hx and Hy fields, maxwell’s curl relations can be used to calculate the remaining field; adapted from the EMpy</p>
</dd></dl>

<dl class="py method">
<dt id="emepy.mode.Mode.get_E">
<code class="sig-name descname">get_E</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#emepy.mode.Mode.get_E" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an array [self.Ex, self.Ey, self.Ez].</p>
</dd></dl>

<dl class="py method">
<dt id="emepy.mode.Mode.get_H">
<code class="sig-name descname">get_H</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#emepy.mode.Mode.get_H" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an array [self.Hx, self.Hy, self.Hz].</p>
</dd></dl>

<dl class="py method">
<dt id="emepy.mode.Mode.get_fields">
<code class="sig-name descname">get_fields</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#emepy.mode.Mode.get_fields" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an array [self.Hx, self.Hy, self.Hz, self.Ex, self.Ey, self.Ez].</p>
</dd></dl>

<dl class="py method">
<dt id="emepy.mode.Mode.get_neff">
<code class="sig-name descname">get_neff</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#emepy.mode.Mode.get_neff" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the effective index as a complex number.</p>
</dd></dl>

<dl class="py method">
<dt id="emepy.mode.Mode.get_wavelength">
<code class="sig-name descname">get_wavelength</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#emepy.mode.Mode.get_wavelength" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the wavelength.</p>
</dd></dl>

<dl class="py method">
<dt id="emepy.mode.Mode.inner_product">
<code class="sig-name descname">inner_product</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mode2</span></em><span class="sig-paren">)</span><a class="headerlink" href="#emepy.mode.Mode.inner_product" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes the inner product between self and the provided Mode</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>mode2</strong> (<a class="reference internal" href="#emepy.mode.Mode" title="emepy.mode.Mode"><em>Mode</em></a>) – second eigenmode in the operation</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the inner product between the modes</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>number</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="emepy.mode.Mode.normalize">
<code class="sig-name descname">normalize</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#emepy.mode.Mode.normalize" title="Permalink to this definition">¶</a></dt>
<dd><p>Normalizes the Mode to power 1.</p>
</dd></dl>

<dl class="py method">
<dt id="emepy.mode.Mode.plot">
<code class="sig-name descname">plot</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">operation</span><span class="o">=</span><span class="default_value">'Real'</span></em>, <em class="sig-param"><span class="n">colorbar</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#emepy.mode.Mode.plot" title="Permalink to this definition">¶</a></dt>
<dd><p>Plots the fields in the mode using pyplot. Should call plt.figure() before and plt.show() or plt.savefig() after</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>operation</strong> (<em>string</em>) – the operation to perform on the fields from (“Real”, “Imaginary”, “Abs”, “Abs^2”) (default:”Real”)</p></li>
<li><p><strong>colorbar</strong> (<em>bool</em>) – if true, will show a colorbar for each field</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="emepy.mode.Mode.plot_material">
<code class="sig-name descname">plot_material</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#emepy.mode.Mode.plot_material" title="Permalink to this definition">¶</a></dt>
<dd><p>Plots the index of refraction profile</p>
</dd></dl>

<dl class="py method">
<dt id="emepy.mode.Mode.save">
<code class="sig-name descname">save</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">path</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#emepy.mode.Mode.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Serializes the mode into a pickle file</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>path</strong> (<em>string</em>) – The path (including name) to save the file.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="emepy.mode.Mode.zero_phase">
<code class="sig-name descname">zero_phase</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#emepy.mode.Mode.zero_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Changes the phase such that the z components are all imaginary and the xy components are all real.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="eme">
<h2>EME<a class="headerlink" href="#eme" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="emepy.eme.Layer">
<em class="property">class </em><code class="sig-prename descclassname">emepy.eme.</code><code class="sig-name descname">Layer</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mode_solvers</span></em>, <em class="sig-param"><span class="n">num_modes</span></em>, <em class="sig-param"><span class="n">wavelength</span></em>, <em class="sig-param"><span class="n">length</span></em><span class="sig-paren">)</span><a class="headerlink" href="#emepy.eme.Layer" title="Permalink to this definition">¶</a></dt>
<dd><p>Layer objects form the building blocks inside of an EME or PeriodicEME. These represent geometric layers of rectangular waveguides that approximate continuous structures.</p>
<dl class="py method">
<dt id="emepy.eme.Layer.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mode_solvers</span></em>, <em class="sig-param"><span class="n">num_modes</span></em>, <em class="sig-param"><span class="n">wavelength</span></em>, <em class="sig-param"><span class="n">length</span></em><span class="sig-paren">)</span><a class="headerlink" href="#emepy.eme.Layer.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Layer class constructor</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mode_solvers</strong> (<em>list</em><em> [</em><em>tuple</em><em> (</em><a class="reference internal" href="#emepy.fd.ModeSolver" title="emepy.fd.ModeSolver"><em>ModeSolver</em></a><em>, </em><em>int</em><em>)</em><em>]</em><em>, </em><em>Modesolver</em>) – List of tuples that contain ModeSolver objects and the number of modes that corresponds to each. Should be in order from fundamental mode to least significant mode. If only one ModeSolver is needed, can simply be that object instead of a list.</p></li>
<li><p><strong>num_modes</strong> (<em>int</em>) – Number of total modes for the layer.</p></li>
<li><p><strong>wavelength</strong> (<em>number</em>) – Wavelength of eigenmode to solve for (m).</p></li>
<li><p><strong>length</strong> (<em>number</em>) – Geometric length of the Layer (m). The length affects the phase of the eigenmodes inside the layer via the complex phasor $e^(jβz)$.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="emepy.eme.Layer.activate_layer">
<code class="sig-name descname">activate_layer</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#emepy.eme.Layer.activate_layer" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves for the modes in the layer and creates an ActivatedLayer object</p>
</dd></dl>

<dl class="py method">
<dt id="emepy.eme.Layer.clear">
<code class="sig-name descname">clear</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#emepy.eme.Layer.clear" title="Permalink to this definition">¶</a></dt>
<dd><p>Empties the modes in the ModeSolver to clear memory</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the edited image</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>numpy array</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="emepy.eme.Layer.get_activated_layer">
<code class="sig-name descname">get_activated_layer</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#emepy.eme.Layer.get_activated_layer" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the activated layer if it exists or calls activate_layer first</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the object that stores the eigenmodes</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#emepy.eme.ActivatedLayer" title="emepy.eme.ActivatedLayer">ActivatedLayer</a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="emepy.eme.EME">
<em class="property">class </em><code class="sig-prename descclassname">emepy.eme.</code><code class="sig-name descname">EME</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">layers</span><span class="o">=</span><span class="default_value">[]</span></em>, <em class="sig-param"><span class="n">num_periods</span><span class="o">=</span><span class="default_value">1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#emepy.eme.EME" title="Permalink to this definition">¶</a></dt>
<dd><p>The EME class is the heart of the package. It provides the algorithm that cascades sections modes together to provide the s-parameters for a geometric structure. The object is dependent on the Layer objects that are fed inside.</p>
<dl class="py method">
<dt id="emepy.eme.EME.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">layers</span><span class="o">=</span><span class="default_value">[]</span></em>, <em class="sig-param"><span class="n">num_periods</span><span class="o">=</span><span class="default_value">1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#emepy.eme.EME.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>EME class constructor</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>layers</strong> (<em>list</em><em> [</em><a class="reference internal" href="#emepy.eme.Layer" title="emepy.eme.Layer"><em>Layer</em></a><em>]</em>) – An list of Layer objects, arranged in the order they belong geometrically. (default: [])</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="emepy.eme.EME.add_layer">
<code class="sig-name descname">add_layer</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">layer</span></em><span class="sig-paren">)</span><a class="headerlink" href="#emepy.eme.EME.add_layer" title="Permalink to this definition">¶</a></dt>
<dd><p>The add_layer method will add a Layer object to the EME object. The object will be geometrically added to the very right side of the structure. Using this method after propagate is useless as the solver has already been called.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>layer</strong> (<a class="reference internal" href="#emepy.eme.Layer" title="emepy.eme.Layer"><em>Layer</em></a>) – Layer object to be appended to the list of Layers inside the EME object.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="emepy.eme.EME.add_monitor">
<code class="sig-name descname">add_monitor</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">axes</span><span class="o">=</span><span class="default_value">'xz'</span></em>, <em class="sig-param"><span class="n">mesh_z</span><span class="o">=</span><span class="default_value">200</span></em>, <em class="sig-param"><span class="n">z_range</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">location</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#emepy.eme.EME.add_monitor" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a monitor associated with the eme object BEFORE the simulation is ran</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>axes</strong> (<em>string</em>) – the spacial axes to capture fields in. Options : ‘xz’ (default), ‘xy’, ‘xz’, ‘xyz’, ‘x’, ‘y’, ‘z’. Currently only ‘xz’ is implemented. Note, propagation is always in z.</p></li>
<li><p><strong>mesh_z</strong> (<em>int</em>) – number of mesh points in z (for periodic structures, will be z * num_periods)</p></li>
<li><p><strong>z_range</strong> (<em>tuple</em>) – tuple or list of the form (start, end) representing the range of the z values to extract</p></li>
<li><p><strong>location</strong> (<em>float</em>) – z coordinate where to save data for a ‘xy’ monitor</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the newly created Monitor object</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#emepy.monitors.Monitor" title="emepy.monitors.Monitor">Monitor</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="emepy.eme.EME.cascade">
<code class="sig-name descname">cascade</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">first</span></em>, <em class="sig-param"><span class="n">second</span></em><span class="sig-paren">)</span><a class="headerlink" href="#emepy.eme.EME.cascade" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the s_parameters between two layer objects</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>first</strong> (<a class="reference internal" href="#emepy.eme.Layer" title="emepy.eme.Layer"><em>Layer</em></a>) – left Layer object</p></li>
<li><p><strong>second</strong> (<a class="reference internal" href="#emepy.eme.Layer" title="emepy.eme.Layer"><em>Layer</em></a>) – right Layer object</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the s_parameters between the two Layers</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>numpy array</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="emepy.eme.EME.draw">
<code class="sig-name descname">draw</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#emepy.eme.EME.draw" title="Permalink to this definition">¶</a></dt>
<dd><p>The draw method sketches a rough approximation for the xz geometry of the structure using pyplot where x is the width of the structure and z is the length. Currently, the drawing is very rough. This will change in the future.</p>
</dd></dl>

<dl class="py method">
<dt id="emepy.eme.EME.propagate">
<code class="sig-name descname">propagate</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">input_array</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#emepy.eme.EME.propagate" title="Permalink to this definition">¶</a></dt>
<dd><p>The propagate method should be called once all Layer objects have been added. This method will call the EME solver and produce s-parameters.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>input_array</strong> (<em>numpy array</em>) – the array representing the input to the device in s paramter format: [left port mode 1, left port mode 2, … left port mode n, right port mode 1, right port mode 2, … right port mode n] (default : [1,0,0,…]) the default represents sending in the fundamental mode of the left port</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="emepy.eme.EME.propagate_period">
<code class="sig-name descname">propagate_period</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">input_array</span></em><span class="sig-paren">)</span><a class="headerlink" href="#emepy.eme.EME.propagate_period" title="Permalink to this definition">¶</a></dt>
<dd><p>The propagate_period method should be called once all Layer objects have been added. This method will call the EME solver and produce s-parameters for ONE period of the structure. If num_periods is set to 1 (default), this method is the same as propagate, except for it returns values.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><ul class="simple">
<li><p><em>s_params</em> – The s_params acquired during propagation</p></li>
<li><p><em>mode_set1</em> – The set of Mode objects that were solved for on the input layer</p></li>
<li><p><em>mode_set2</em> – The set of Mode objects that were solved for on the output layer</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="emepy.eme.EME.reset">
<code class="sig-name descname">reset</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">full_reset</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#emepy.eme.EME.reset" title="Permalink to this definition">¶</a></dt>
<dd><p>Clears out the layers and s params so the user can reuse the object in memory on a new geometry</p>
</dd></dl>

<dl class="py method">
<dt id="emepy.eme.EME.s_parameters">
<code class="sig-name descname">s_parameters</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">freqs</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#emepy.eme.EME.s_parameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the s_parameters if they exist. If they don’t exist yet, propagate() will be called first.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The s_params acquired during propagation</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>numpy array</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="emepy.lumerical.LumEME">
<em class="property">class </em><code class="sig-prename descclassname">emepy.lumerical.</code><code class="sig-name descname">LumEME</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">layers</span><span class="o">=</span><span class="default_value">[]</span></em>, <em class="sig-param"><span class="n">num_periods</span><span class="o">=</span><span class="default_value">1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#emepy.lumerical.LumEME" title="Permalink to this definition">¶</a></dt>
<dd><p>This class is a wrapper for EME, it performs the same operations but uses Lumerical MODE to solve for the modes at the interfaces</p>
<dl class="py method">
<dt id="emepy.lumerical.LumEME.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">layers</span><span class="o">=</span><span class="default_value">[]</span></em>, <em class="sig-param"><span class="n">num_periods</span><span class="o">=</span><span class="default_value">1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#emepy.lumerical.LumEME.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>EME class constructor</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>layers</strong> (<em>list</em><em> [</em><a class="reference internal" href="#emepy.eme.Layer" title="emepy.eme.Layer"><em>Layer</em></a><em>]</em>) – An list of Layer objects, arranged in the order they belong geometrically. (default: [])</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="emepy.eme.Current">
<em class="property">class </em><code class="sig-prename descclassname">emepy.eme.</code><code class="sig-name descname">Current</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">wavelength</span></em>, <em class="sig-param"><span class="n">s</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#emepy.eme.Current" title="Permalink to this definition">¶</a></dt>
<dd><p>The object that the EME uses to track the s_parameters and cascade them as they come along to save memory</p>
<dl class="py method">
<dt id="emepy.eme.Current.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">wavelength</span></em>, <em class="sig-param"><span class="n">s</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#emepy.eme.Current.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Current class constructor</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>wavelength</strong> (<em>number</em>) – the wavelength of the simulation</p></li>
<li><p><strong>s</strong> (<em>numpy array</em>) – the starting scattering matrix</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="emepy.eme.Current.s_parameters">
<code class="sig-name descname">s_parameters</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">freq</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#emepy.eme.Current.s_parameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the scattering matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the scattering matrix</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>numpy array</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="emepy.eme.Current.update_s">
<code class="sig-name descname">update_s</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">s</span></em>, <em class="sig-param"><span class="n">layer</span></em><span class="sig-paren">)</span><a class="headerlink" href="#emepy.eme.Current.update_s" title="Permalink to this definition">¶</a></dt>
<dd><p>Updates the scattering matrix of the object</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>s</strong> (<em>numpy array</em>) – scattering matrix to use as the update</p></li>
<li><p><strong>layer</strong> (<a class="reference internal" href="#emepy.eme.Layer" title="emepy.eme.Layer"><em>Layer</em></a>) – the layer object whos ports to match</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="emepy.eme.ActivatedLayer">
<em class="property">class </em><code class="sig-prename descclassname">emepy.eme.</code><code class="sig-name descname">ActivatedLayer</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">modes</span></em>, <em class="sig-param"><span class="n">wavelength</span></em>, <em class="sig-param"><span class="n">length</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#emepy.eme.ActivatedLayer" title="Permalink to this definition">¶</a></dt>
<dd><p>ActivatedLayer is produced by the Layer class after the ModeSolvers calculate eigenmodes. This is used to create interfaces. This inherits from Simphony’s Model class.</p>
<dl class="py method">
<dt id="emepy.eme.ActivatedLayer.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">modes</span></em>, <em class="sig-param"><span class="n">wavelength</span></em>, <em class="sig-param"><span class="n">length</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#emepy.eme.ActivatedLayer.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>ActivatedLayer class constructor</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>modes</strong> (<em>list</em><em> [</em><a class="reference internal" href="#emepy.mode.Mode" title="emepy.mode.Mode"><em>Mode</em></a><em>]</em>) – list of solved eigenmodes in Mode class form</p></li>
<li><p><strong>wavelength</strong> (<em>number</em>) – the wavelength of the eigenmodes</p></li>
<li><p><strong>length</strong> (<em>number</em>) – the length of the layer object that produced the eigenmodes. This number is used for phase propagation.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="emepy.eme.ActivatedLayer.calculate_s_params">
<code class="sig-name descname">calculate_s_params</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#emepy.eme.ActivatedLayer.calculate_s_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the s params for the phase propagation and returns it.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the scattering matrix for phase propagation.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>numpy array</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="emepy.eme.ActivatedLayer.normalize_fields">
<code class="sig-name descname">normalize_fields</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#emepy.eme.ActivatedLayer.normalize_fields" title="Permalink to this definition">¶</a></dt>
<dd><p>Normalizes all of the eigenmodes such that the overlap with its self, power, is 1.</p>
</dd></dl>

<dl class="py method">
<dt id="emepy.eme.ActivatedLayer.s_parameters">
<code class="sig-name descname">s_parameters</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">freq</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#emepy.eme.ActivatedLayer.s_parameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the scattering matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the scattering matrix</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>numpy array</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="emepy.eme.PeriodicLayer">
<em class="property">class </em><code class="sig-prename descclassname">emepy.eme.</code><code class="sig-name descname">PeriodicLayer</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">left_modes</span></em>, <em class="sig-param"><span class="n">right_modes</span></em>, <em class="sig-param"><span class="n">s_params</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#emepy.eme.PeriodicLayer" title="Permalink to this definition">¶</a></dt>
<dd><p>PeriodicLayer behaves similar to ActivatedLayer. However, this class can represent an entire geometry that is repeated in the periodic structure. It also gets constantly updated as it cascades through periods.</p>
<dl class="py method">
<dt id="emepy.eme.PeriodicLayer.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">left_modes</span></em>, <em class="sig-param"><span class="n">right_modes</span></em>, <em class="sig-param"><span class="n">s_params</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#emepy.eme.PeriodicLayer.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>PeriodicLayer class constructor</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>left_modes</strong> (<em>list</em><em> [</em><a class="reference internal" href="#emepy.mode.Mode" title="emepy.mode.Mode"><em>Mode</em></a><em>]</em>) – list of the eigenmodes on the left side of the layer</p></li>
<li><p><strong>right_modes</strong> (<em>list</em><em> [</em><a class="reference internal" href="#emepy.mode.Mode" title="emepy.mode.Mode"><em>Mode</em></a><em>]</em>) – list of the eigenmodes on the right side of the layer</p></li>
<li><p><strong>s_params</strong> – the scattering matrix that represents the layer, which includes both propagation and mode overlaps</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="emepy.eme.PeriodicLayer.normalize_fields">
<code class="sig-name descname">normalize_fields</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#emepy.eme.PeriodicLayer.normalize_fields" title="Permalink to this definition">¶</a></dt>
<dd><p>Normalizes all of the eigenmodes such that the overlap with its self, power, is 1.</p>
</dd></dl>

<dl class="py method">
<dt id="emepy.eme.PeriodicLayer.s_parameters">
<code class="sig-name descname">s_parameters</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">freqs</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#emepy.eme.PeriodicLayer.s_parameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the scattering matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the scattering matrix</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>numpy array</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="emepy.eme.InterfaceSingleMode">
<em class="property">class </em><code class="sig-prename descclassname">emepy.eme.</code><code class="sig-name descname">InterfaceSingleMode</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">layer1</span></em>, <em class="sig-param"><span class="n">layer2</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#emepy.eme.InterfaceSingleMode" title="Permalink to this definition">¶</a></dt>
<dd><p>The InterfaceSingleMode class represents the interface between two different layers. This class is an approximation to speed up the process and can ONLY be used during single mode EME.</p>
<dl class="py method">
<dt id="emepy.eme.InterfaceSingleMode.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">layer1</span></em>, <em class="sig-param"><span class="n">layer2</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#emepy.eme.InterfaceSingleMode.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>InterfaceSingleMode class constructor</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>layer1</strong> (<a class="reference internal" href="#emepy.eme.Layer" title="emepy.eme.Layer"><em>Layer</em></a>) – the left Layer object of the interface</p></li>
<li><p><strong>layer2</strong> (<a class="reference internal" href="#emepy.eme.Layer" title="emepy.eme.Layer"><em>Layer</em></a>) – the right Layer object of the interface</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="emepy.eme.InterfaceSingleMode.clear">
<code class="sig-name descname">clear</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#emepy.eme.InterfaceSingleMode.clear" title="Permalink to this definition">¶</a></dt>
<dd><p>Clears the scattering matrix in the object</p>
</dd></dl>

<dl class="py method">
<dt id="emepy.eme.InterfaceSingleMode.get_values">
<code class="sig-name descname">get_values</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">left</span></em>, <em class="sig-param"><span class="n">right</span></em><span class="sig-paren">)</span><a class="headerlink" href="#emepy.eme.InterfaceSingleMode.get_values" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the reflection and transmission coefficient based on the two modes</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>left</strong> (<a class="reference internal" href="#emepy.mode.Mode" title="emepy.mode.Mode"><em>Mode</em></a>) – leftside eigenmode</p></li>
<li><p><strong>right</strong> (<a class="reference internal" href="#emepy.mode.Mode" title="emepy.mode.Mode"><em>Mode</em></a>) – rightside eigenmode</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>r</strong> (<em>number</em>) – reflection coefficient</p></li>
<li><p><strong>t</strong> (<em>number</em>) – transmission coefficient</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="emepy.eme.InterfaceSingleMode.s_parameters">
<code class="sig-name descname">s_parameters</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">freqs</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#emepy.eme.InterfaceSingleMode.s_parameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the scattering matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the scattering matrix</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>numpy array</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="emepy.eme.InterfaceSingleMode.solve">
<code class="sig-name descname">solve</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#emepy.eme.InterfaceSingleMode.solve" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves for the scattering matrix based on transmission and reflection</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="emepy.eme.InterfaceMultiMode">
<em class="property">class </em><code class="sig-prename descclassname">emepy.eme.</code><code class="sig-name descname">InterfaceMultiMode</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">layer1</span></em>, <em class="sig-param"><span class="n">layer2</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#emepy.eme.InterfaceMultiMode" title="Permalink to this definition">¶</a></dt>
<dd><p>The InterfaceMultiMode class represents the interface between two different layers.</p>
<dl class="py method">
<dt id="emepy.eme.InterfaceMultiMode.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">layer1</span></em>, <em class="sig-param"><span class="n">layer2</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#emepy.eme.InterfaceMultiMode.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>InterfaceMultiMode class constructor</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>layer1</strong> (<a class="reference internal" href="#emepy.eme.Layer" title="emepy.eme.Layer"><em>Layer</em></a>) – the left Layer object of the interface</p></li>
<li><p><strong>layer2</strong> (<a class="reference internal" href="#emepy.eme.Layer" title="emepy.eme.Layer"><em>Layer</em></a>) – the right Layer object of the interface</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="emepy.eme.InterfaceMultiMode.clear">
<code class="sig-name descname">clear</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#emepy.eme.InterfaceMultiMode.clear" title="Permalink to this definition">¶</a></dt>
<dd><p>Clears the scattering matrix in the object</p>
</dd></dl>

<dl class="py method">
<dt id="emepy.eme.InterfaceMultiMode.get_r">
<code class="sig-name descname">get_r</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">p</span></em>, <em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">left</span></em>, <em class="sig-param"><span class="n">right</span></em>, <em class="sig-param"><span class="n">curr_ports</span></em><span class="sig-paren">)</span><a class="headerlink" href="#emepy.eme.InterfaceMultiMode.get_r" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the transmission coefficient based on the two modes</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>p</strong> (<em>int</em>) – port number to look at</p></li>
<li><p><strong>left</strong> (<a class="reference internal" href="#emepy.mode.Mode" title="emepy.mode.Mode"><em>Mode</em></a>) – leftside eigenmode</p></li>
<li><p><strong>right</strong> (<a class="reference internal" href="#emepy.mode.Mode" title="emepy.mode.Mode"><em>Mode</em></a>) – rightside eigenmode</p></li>
<li><p><strong>curr_ports</strong> (<em>int</em>) – total number of ports</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>r</strong> – reflection coefficient</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>number</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="emepy.eme.InterfaceMultiMode.get_t">
<code class="sig-name descname">get_t</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">p</span></em>, <em class="sig-param"><span class="n">left</span></em>, <em class="sig-param"><span class="n">right</span></em>, <em class="sig-param"><span class="n">curr_ports</span></em><span class="sig-paren">)</span><a class="headerlink" href="#emepy.eme.InterfaceMultiMode.get_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the transmission coefficient based on the two modes</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>p</strong> (<em>int</em>) – port number to look at</p></li>
<li><p><strong>left</strong> (<a class="reference internal" href="#emepy.mode.Mode" title="emepy.mode.Mode"><em>Mode</em></a>) – leftside eigenmode</p></li>
<li><p><strong>right</strong> (<a class="reference internal" href="#emepy.mode.Mode" title="emepy.mode.Mode"><em>Mode</em></a>) – rightside eigenmode</p></li>
<li><p><strong>curr_ports</strong> (<em>int</em>) – total number of ports</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>t</strong> – transmission coefficient</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>number</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="emepy.eme.InterfaceMultiMode.s_parameters">
<code class="sig-name descname">s_parameters</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">freqs</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#emepy.eme.InterfaceMultiMode.s_parameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the scattering matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the scattering matrix</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>numpy array</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="emepy.eme.InterfaceMultiMode.solve">
<code class="sig-name descname">solve</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#emepy.eme.InterfaceMultiMode.solve" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves for the scattering matrix based on transmission and reflection</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="modesolver">
<h2>ModeSolver<a class="headerlink" href="#modesolver" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="emepy.fd.ModeSolver">
<em class="property">class </em><code class="sig-prename descclassname">emepy.fd.</code><code class="sig-name descname">ModeSolver</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#emepy.fd.ModeSolver" title="Permalink to this definition">¶</a></dt>
<dd><p>The ModeSolver object is the heart of finding eigenmodes for use in eigenmode expansion or simple examination. This parent class should be inherited and used as a wrapper for certain modules such as EMpy, Lumerical, Pickled data, Neural Networks, etc.</p>
<dl class="py method">
<dt id="emepy.fd.ModeSolver.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#emepy.fd.ModeSolver.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>ModeSolver class constructor</p>
</dd></dl>

<dl class="py method">
<dt id="emepy.fd.ModeSolver.clear">
<code class="sig-name descname">clear</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#emepy.fd.ModeSolver.clear" title="Permalink to this definition">¶</a></dt>
<dd><p>Clears the modesolver’s eigenmodes to make memory</p>
</dd></dl>

<dl class="py method">
<dt id="emepy.fd.ModeSolver.get_mode">
<code class="sig-name descname">get_mode</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mode_num</span></em><span class="sig-paren">)</span><a class="headerlink" href="#emepy.fd.ModeSolver.get_mode" title="Permalink to this definition">¶</a></dt>
<dd><p>Must extract the mode of choice</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>mode_num</strong> (<em>int</em>) – index of the mode of choice</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="emepy.fd.ModeSolver.solve">
<code class="sig-name descname">solve</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#emepy.fd.ModeSolver.solve" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves the eigenmode solver for the specific eigenmodes of desire</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="emepy.lumerical.MSLumerical">
<em class="property">class </em><code class="sig-prename descclassname">emepy.lumerical.</code><code class="sig-name descname">MSLumerical</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">wl</span></em>, <em class="sig-param"><span class="n">width</span></em>, <em class="sig-param"><span class="n">thickness</span></em>, <em class="sig-param"><span class="n">num_modes</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">cladding_width</span><span class="o">=</span><span class="default_value">1e-05</span></em>, <em class="sig-param"><span class="n">cladding_thickness</span><span class="o">=</span><span class="default_value">1e-05</span></em>, <em class="sig-param"><span class="n">core_index</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">cladding_index</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">mesh</span><span class="o">=</span><span class="default_value">300</span></em>, <em class="sig-param"><span class="n">mode</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">eme_modes</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">PML</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#emepy.lumerical.MSLumerical" title="Permalink to this definition">¶</a></dt>
<dd><p>Outdated Lumerical Modesolver. Uses the lumapi Lumerical API. See Modesolver. Parameterizes the cross section as a rectangular waveguide.</p>
<dl class="py method">
<dt id="emepy.lumerical.MSLumerical.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">wl</span></em>, <em class="sig-param"><span class="n">width</span></em>, <em class="sig-param"><span class="n">thickness</span></em>, <em class="sig-param"><span class="n">num_modes</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">cladding_width</span><span class="o">=</span><span class="default_value">1e-05</span></em>, <em class="sig-param"><span class="n">cladding_thickness</span><span class="o">=</span><span class="default_value">1e-05</span></em>, <em class="sig-param"><span class="n">core_index</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">cladding_index</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">mesh</span><span class="o">=</span><span class="default_value">300</span></em>, <em class="sig-param"><span class="n">mode</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">eme_modes</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">PML</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#emepy.lumerical.MSLumerical.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>MSLumerical class constructor</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>wl</strong> (<em>number</em>) – wavelength of the eigenmodes</p></li>
<li><p><strong>width</strong> (<em>number</em>) – width of the core in the cross section</p></li>
<li><p><strong>thickness</strong> (<em>number</em>) – thickness of the core in the cross section</p></li>
<li><p><strong>num_modes</strong> (<em>int</em>) – number of modes to solve for (default:1)</p></li>
<li><p><strong>cladding_width</strong> (<em>number</em>) – width of the cladding in the cross section (default:5e-6)</p></li>
<li><p><strong>cladding_thickness</strong> (<em>number</em>) – thickness of the cladding in the cross section (default:5e-6)</p></li>
<li><p><strong>core_index</strong> (<em>number</em>) – refractive index of the core (default:Si)</p></li>
<li><p><strong>cladding_index</strong> (<em>number</em>) – refractive index of the cladding (default:SiO2)</p></li>
<li><p><strong>mesh</strong> (<em>int</em>) – number of mesh points in each direction (xy)</p></li>
<li><p><strong>mode</strong> (<em>lumapi.MODE</em>) – MODE object that contains the file information</p></li>
<li><p><strong>eme_modes</strong> (<em>boolean</em>) – if true, will utilize the lumerical eme wrapped fde solver which is not normalized to one. Produces slightly different results purely due to roundoff error during normalization.</p></li>
<li><p><strong>PML</strong> (<em>boolean</em>) – if true, will enable PML boundary conditions, note: this will increase the mesh and grid space</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="emepy.lumerical.MSLumerical.clear">
<code class="sig-name descname">clear</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#emepy.lumerical.MSLumerical.clear" title="Permalink to this definition">¶</a></dt>
<dd><p>Clears the modesolver’s eigenmodes to make memory</p>
</dd></dl>

<dl class="py method">
<dt id="emepy.lumerical.MSLumerical.get_mode">
<code class="sig-name descname">get_mode</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mode_num</span><span class="o">=</span><span class="default_value">0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#emepy.lumerical.MSLumerical.get_mode" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the indexed mode number</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>mode_num</strong> (<em>int</em>) – index of the mode of choice</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the eigenmode of index mode_num</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#emepy.mode.Mode" title="emepy.mode.Mode">Mode</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="emepy.lumerical.MSLumerical.solve">
<code class="sig-name descname">solve</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#emepy.lumerical.MSLumerical.solve" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves for the eigenmodes</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="emepy.fd.MSEMpy">
<em class="property">class </em><code class="sig-prename descclassname">emepy.fd.</code><code class="sig-name descname">MSEMpy</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">wl</span></em>, <em class="sig-param"><span class="n">width</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">thickness</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">num_modes</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">cladding_width</span><span class="o">=</span><span class="default_value">2.5e-06</span></em>, <em class="sig-param"><span class="n">cladding_thickness</span><span class="o">=</span><span class="default_value">2.5e-06</span></em>, <em class="sig-param"><span class="n">core_index</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">cladding_index</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">x</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">mesh</span><span class="o">=</span><span class="default_value">128</span></em>, <em class="sig-param"><span class="n">accuracy</span><span class="o">=</span><span class="default_value">1e-08</span></em>, <em class="sig-param"><span class="n">boundary</span><span class="o">=</span><span class="default_value">'0000'</span></em>, <em class="sig-param"><span class="n">epsfunc</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">n</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#emepy.fd.MSEMpy" title="Permalink to this definition">¶</a></dt>
<dd><p>Electromagnetic Python Modesolver. Uses the EMpy library See Modesolver. Parameterizes the cross section as a rectangular waveguide.</p>
<dl class="py method">
<dt id="emepy.fd.MSEMpy.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">wl</span></em>, <em class="sig-param"><span class="n">width</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">thickness</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">num_modes</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">cladding_width</span><span class="o">=</span><span class="default_value">2.5e-06</span></em>, <em class="sig-param"><span class="n">cladding_thickness</span><span class="o">=</span><span class="default_value">2.5e-06</span></em>, <em class="sig-param"><span class="n">core_index</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">cladding_index</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">x</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">mesh</span><span class="o">=</span><span class="default_value">128</span></em>, <em class="sig-param"><span class="n">accuracy</span><span class="o">=</span><span class="default_value">1e-08</span></em>, <em class="sig-param"><span class="n">boundary</span><span class="o">=</span><span class="default_value">'0000'</span></em>, <em class="sig-param"><span class="n">epsfunc</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">n</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#emepy.fd.MSEMpy.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>MSEMpy class constructor</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>wl</strong> (<em>number</em>) – wavelength of the eigenmodes</p></li>
<li><p><strong>width</strong> (<em>number</em>) – width of the core in the cross section</p></li>
<li><p><strong>thickness</strong> (<em>number</em>) – thickness of the core in the cross section</p></li>
<li><p><strong>num_modes</strong> (<em>int</em>) – number of modes to solve for (default:1)</p></li>
<li><p><strong>cladding_width</strong> (<em>number</em>) – width of the cladding in the cross section (default:5e-6)</p></li>
<li><p><strong>cladding_thickness</strong> (<em>number</em>) – thickness of the cladding in the cross section (default:5e-6)</p></li>
<li><p><strong>core_index</strong> (<em>number</em>) – refractive index of the core (default:Si)</p></li>
<li><p><strong>cladding_index</strong> (<em>number</em>) – refractive index of the cladding (default:SiO2)</p></li>
<li><p><strong>mesh</strong> (<em>int</em>) – number of mesh points in each direction (xy)</p></li>
<li><p><strong>x</strong> (<em>numpy array</em>) – the cross section grid in the x direction (z propagation) (default:None)</p></li>
<li><p><strong>y</strong> (<em>numpy array</em>) – the cross section grid in the y direction (z propagation) (default:None)</p></li>
<li><p><strong>mesh</strong> – the number of mesh points in each xy direction</p></li>
<li><p><strong>accuracy</strong> (<em>number</em>) – the minimum accuracy of the finite difference solution (default:1e-8)</p></li>
<li><p><strong>boundary</strong> (<em>string</em>) – the boundaries according to the EMpy library (default:”0000”)</p></li>
<li><p><strong>epsfunc</strong> (<em>function</em>) – the function which defines the permittivity based on a grid (see EMpy library) (default:”0000”)</p></li>
<li><p><strong>n</strong> (<em>numpy array</em>) – 2D profile of the refractive index</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="emepy.fd.MSEMpy.clear">
<code class="sig-name descname">clear</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#emepy.fd.MSEMpy.clear" title="Permalink to this definition">¶</a></dt>
<dd><p>Clears the modesolver’s eigenmodes to make memory</p>
</dd></dl>

<dl class="py method">
<dt id="emepy.fd.MSEMpy.get_mode">
<code class="sig-name descname">get_mode</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mode_num</span><span class="o">=</span><span class="default_value">0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#emepy.fd.MSEMpy.get_mode" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the indexed mode number</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>mode_num</strong> (<em>int</em>) – index of the mode of choice</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the eigenmode of index mode_num</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#emepy.mode.Mode" title="emepy.mode.Mode">Mode</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="emepy.fd.MSEMpy.solve">
<code class="sig-name descname">solve</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#emepy.fd.MSEMpy.solve" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves for the eigenmodes</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="emepy.fd.MSPickle">
<em class="property">class </em><code class="sig-prename descclassname">emepy.fd.</code><code class="sig-name descname">MSPickle</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">filename</span></em>, <em class="sig-param"><span class="n">index</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">width</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">thickness</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#emepy.fd.MSPickle" title="Permalink to this definition">¶</a></dt>
<dd><p>Pickle Modesolver. See Modesolver. Pickle should serialize a list of Mode objects that can be opened here.</p>
<dl class="py method">
<dt id="emepy.fd.MSPickle.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">filename</span></em>, <em class="sig-param"><span class="n">index</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">width</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">thickness</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#emepy.fd.MSPickle.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>MSPickle class constructor</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>filename</strong> (<em>string</em>) – the name of the pickled file where the eigenmode is stored</p></li>
<li><p><strong>index</strong> (<em>int</em>) – the index of the mode in the pickle file if the data stored is an array of Modes (default:None)</p></li>
<li><p><strong>width</strong> (<em>number</em>) – width of the core in the cross section, used for drawing (default:None)</p></li>
<li><p><strong>thickness</strong> (<em>number</em>) – thickness of the core in the cross section, used for drawing  (default:None)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="emepy.fd.MSPickle.clear">
<code class="sig-name descname">clear</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#emepy.fd.MSPickle.clear" title="Permalink to this definition">¶</a></dt>
<dd><p>Clears the modesolver’s eigenmodes to make memory</p>
</dd></dl>

<dl class="py method">
<dt id="emepy.fd.MSPickle.get_mode">
<code class="sig-name descname">get_mode</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mode_num</span><span class="o">=</span><span class="default_value">0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#emepy.fd.MSPickle.get_mode" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the stored mode</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the eigenmode of index mode_num</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#emepy.mode.Mode" title="emepy.mode.Mode">Mode</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="emepy.fd.MSPickle.solve">
<code class="sig-name descname">solve</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#emepy.fd.MSPickle.solve" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves for the eigenmodes by loading them from the pickle file</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="monitors">
<h2>Monitors<a class="headerlink" href="#monitors" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="emepy.monitors.Monitor">
<em class="property">class </em><code class="sig-prename descclassname">emepy.monitors.</code><code class="sig-name descname">Monitor</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">axes</span><span class="o">=</span><span class="default_value">'xz'</span></em>, <em class="sig-param"><span class="n">dimensions</span><span class="o">=</span><span class="default_value">(1, 1)</span></em>, <em class="sig-param"><span class="n">lengths</span><span class="o">=</span><span class="default_value">[]</span></em>, <em class="sig-param"><span class="n">components</span><span class="o">=</span><span class="default_value">['E']</span></em>, <em class="sig-param"><span class="n">z_range</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">grid_x</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">grid_y</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">grid_z</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">location</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#emepy.monitors.Monitor" title="Permalink to this definition">¶</a></dt>
<dd><p>Monitor objects store fields during propagation for user visualization. Three types of monitors exist: 3D, 2D, and 1D.</p>
<dl class="py method">
<dt id="emepy.monitors.Monitor.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">axes</span><span class="o">=</span><span class="default_value">'xz'</span></em>, <em class="sig-param"><span class="n">dimensions</span><span class="o">=</span><span class="default_value">(1, 1)</span></em>, <em class="sig-param"><span class="n">lengths</span><span class="o">=</span><span class="default_value">[]</span></em>, <em class="sig-param"><span class="n">components</span><span class="o">=</span><span class="default_value">['E']</span></em>, <em class="sig-param"><span class="n">z_range</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">grid_x</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">grid_y</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">grid_z</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">location</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#emepy.monitors.Monitor.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Monitor class constructor</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>axes</strong> (<em>string</em>) – the spacial axes to capture fields in. Options : ‘xz’ (default), ‘xy’, ‘yz’, ‘xyz’, ‘x’, ‘y’, ‘z’. Note, propagation is always in z.</p></li>
<li><p><strong>dimensions</strong> (<em>tuple</em>) – the spacial dimensions of the resulting field</p></li>
<li><p><strong>lengths</strong> (<em>list</em>) – list of the remaining points in z at which to calculate the fields</p></li>
<li><p><strong>components</strong> (<em>list</em>) – list of the field components to store from (‘E’,’H’,’Ex’,’Ey’,’Ez’,’Hx’,’Hy’,’Hz)</p></li>
<li><p><strong>z_range</strong> (<em>tuple</em>) – tuple or list of the form (start, end) representing the range of the z values to extract</p></li>
<li><p><strong>grid_x</strong> (<em>numpy array</em>) – 1d x grid</p></li>
<li><p><strong>grid_y</strong> (<em>numpy array</em>) – 1d y grid</p></li>
<li><p><strong>grid_z</strong> (<em>numpy array</em>) – 1d z grid</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="emepy.monitors.Monitor.get_array">
<code class="sig-name descname">get_array</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">component</span><span class="o">=</span><span class="default_value">'Hy'</span></em>, <em class="sig-param"><span class="n">axes</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">location</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">z_range</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">grid_x</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">grid_y</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#emepy.monitors.Monitor.get_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a matplotlib axis displaying the provides field component</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>axes</strong> (<em>string</em>) – the spacial axes to capture fields in. Options : ‘xz’ (default), ‘xy’, ‘yz’, ‘xyz’, ‘x’, ‘y’, ‘z’. Note, propagation is always in z.</p></li>
<li><p><strong>component</strong> (<em>string</em>) – field component from “[‘Ex’,’Ey’,’Ez’,’Hx’,’Hy’,’Hz’,’E’,’H’]”</p></li>
<li><p><strong>location</strong> (<em>float</em>) – if taken from 3D fields, users can specify where to take their 2D slice. If axes is ‘xz’, location refers to the location in y and ‘yz’ refers to a location in x and ‘xy’ refers to a location in z</p></li>
<li><p><strong>z_range</strong> (<em>tuple</em>) – tuple or list of the form (start, end) representing the range of the z values to extract</p></li>
<li><p><strong>grid_x</strong> (<em>numpy array</em>) – custom x grid to interpolate onto</p></li>
<li><p><strong>grid_y</strong> (<em>numpy array</em>) – custom y grid to interpolate onto</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the requested field</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>numpy array</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="emepy.monitors.Monitor.visualize">
<code class="sig-name descname">visualize</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ax</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">component</span><span class="o">=</span><span class="default_value">'Hy'</span></em>, <em class="sig-param"><span class="n">axes</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">location</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">z_range</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#emepy.monitors.Monitor.visualize" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a matplotlib axis displaying the provides field component</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>axes</strong> (<em>string</em>) – the spacial axes to capture fields in. Options : ‘xz’ (default), ‘xy’, ‘yz’, ‘xyz’, ‘x’, ‘y’, ‘z’. Note, propagation is always in z.</p></li>
<li><p><strong>ax</strong> (<em>matplotlib axis</em>) – the axis object created when calling plt.figure() or plt.subplots(), if None (default) then the plt interface will be used</p></li>
<li><p><strong>component</strong> (<em>string</em>) – field component from “[‘Ex’,’Ey’,’Ez’,’Hx’,’Hy’,’Hz’,’E’,’H’]”</p></li>
<li><p><strong>location</strong> (<em>float</em>) – if taken from 3D fields, users can specify where to take their 2D slice. If axes is ‘xz’, location refers to the location in y and ‘yz’ refers to a location in x and ‘xy’ refers to a location in z.</p></li>
<li><p><strong>z_range</strong> (<em>tuple</em>) – tuple or list of the form (start, end) representing the range of the z values to extract</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="neural-network-acceleration">
<h2>Neural Network Acceleration<a class="headerlink" href="#neural-network-acceleration" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="emepy.ann.MSNeuralNetwork">
<em class="property">class </em><code class="sig-prename descclassname">emepy.ann.</code><code class="sig-name descname">MSNeuralNetwork</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ann</span></em>, <em class="sig-param"><span class="n">wl</span></em>, <em class="sig-param"><span class="n">width</span></em>, <em class="sig-param"><span class="n">thickness</span></em><span class="sig-paren">)</span><a class="headerlink" href="#emepy.ann.MSNeuralNetwork" title="Permalink to this definition">¶</a></dt>
<dd><p>ModeSolver object for the sample neural networks, parameterizes the cross section components. Currently designed only for single mode calculations in Silicon on SiO2</p>
<dl class="py method">
<dt id="emepy.ann.MSNeuralNetwork.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ann</span></em>, <em class="sig-param"><span class="n">wl</span></em>, <em class="sig-param"><span class="n">width</span></em>, <em class="sig-param"><span class="n">thickness</span></em><span class="sig-paren">)</span><a class="headerlink" href="#emepy.ann.MSNeuralNetwork.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>MSNeuralNetwork constructor</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ann</strong> (<a class="reference internal" href="#emepy.ann.ANN" title="emepy.ann.ANN"><em>ANN</em></a>) – The ANN object that contains the network and regression models</p></li>
<li><p><strong>wl</strong> (<em>number</em>) – The wavelength (most accurate around 1.55 µm)</p></li>
<li><p><strong>width</strong> (<em>number</em>) – The width of the cross section (most accurate around 550 nm)</p></li>
<li><p><strong>thickness</strong> (<em>number</em>) – The thickness of the cross section (most accurate around 250 nm)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="emepy.ann.MSNeuralNetwork.Hx_network">
<code class="sig-name descname">Hx_network</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">width</span></em>, <em class="sig-param"><span class="n">thickness</span></em>, <em class="sig-param"><span class="n">wl</span></em>, <em class="sig-param"><span class="n">model</span></em><span class="sig-paren">)</span><a class="headerlink" href="#emepy.ann.MSNeuralNetwork.Hx_network" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the Hx component using a network model</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>width</strong> (<em>number</em>) – The width of the cross section (most accurate around 550 nm)</p></li>
<li><p><strong>thickness</strong> (<em>number</em>) – The thickness of the cross section (most accurate around 250 nm)</p></li>
<li><p><strong>wl</strong> (<em>number</em>) – The wavelength (most accurate around 1.55 µm)</p></li>
<li><p><strong>model</strong> (<em>pytorch model</em>) – The model that performs the ann calculation</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Returns the Hx field</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>numpy array</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="emepy.ann.MSNeuralNetwork.Hy_network">
<code class="sig-name descname">Hy_network</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">width</span></em>, <em class="sig-param"><span class="n">thickness</span></em>, <em class="sig-param"><span class="n">wl</span></em>, <em class="sig-param"><span class="n">model</span></em><span class="sig-paren">)</span><a class="headerlink" href="#emepy.ann.MSNeuralNetwork.Hy_network" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the Hy component using a network model</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>width</strong> (<em>number</em>) – The width of the cross section (most accurate around 550 nm)</p></li>
<li><p><strong>thickness</strong> (<em>number</em>) – The thickness of the cross section (most accurate around 250 nm)</p></li>
<li><p><strong>wl</strong> (<em>number</em>) – The wavelength (most accurate around 1.55 µm)</p></li>
<li><p><strong>model</strong> (<em>pytorch model</em>) – The model that performs the ann calculation</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Returns the Hy field</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>numpy array</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="emepy.ann.MSNeuralNetwork.clear">
<code class="sig-name descname">clear</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#emepy.ann.MSNeuralNetwork.clear" title="Permalink to this definition">¶</a></dt>
<dd><p>Clears the mode in the object</p>
</dd></dl>

<dl class="py method">
<dt id="emepy.ann.MSNeuralNetwork.data">
<code class="sig-name descname">data</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">width</span></em>, <em class="sig-param"><span class="n">thickness</span></em>, <em class="sig-param"><span class="n">wl</span></em><span class="sig-paren">)</span><a class="headerlink" href="#emepy.ann.MSNeuralNetwork.data" title="Permalink to this definition">¶</a></dt>
<dd><p>Propagates the inputs into the neural networks and regression models and returns the outputs</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>width</strong> (<em>number</em>) – The width of the cross section (most accurate around 550 nm)</p></li>
<li><p><strong>thickness</strong> (<em>number</em>) – The thickness of the cross section (most accurate around 250 nm)</p></li>
<li><p><strong>wl</strong> (<em>number</em>) – The wavelength (most accurate around 1.55 µm)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Returns Hx, Hy, and neff</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tuple (numpy array, numpy array, number)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="emepy.ann.MSNeuralNetwork.get_mode">
<code class="sig-name descname">get_mode</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">mode_num</span><span class="o">=</span><span class="default_value">0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#emepy.ann.MSNeuralNetwork.get_mode" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the solved eigenmode</p>
</dd></dl>

<dl class="py method">
<dt id="emepy.ann.MSNeuralNetwork.neff_regression">
<code class="sig-name descname">neff_regression</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">width</span></em>, <em class="sig-param"><span class="n">thickness</span></em>, <em class="sig-param"><span class="n">wl</span></em>, <em class="sig-param"><span class="n">model</span></em><span class="sig-paren">)</span><a class="headerlink" href="#emepy.ann.MSNeuralNetwork.neff_regression" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the effective index using a regression model</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>width</strong> (<em>number</em>) – The width of the cross section (most accurate around 550 nm)</p></li>
<li><p><strong>thickness</strong> (<em>number</em>) – The thickness of the cross section (most accurate around 250 nm)</p></li>
<li><p><strong>wl</strong> (<em>number</em>) – The wavelength (most accurate around 1.55 µm)</p></li>
<li><p><strong>model</strong> (<em>sklearn regression model</em>) – The model that performs the regression</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Returns the effective index</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>number</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="emepy.ann.MSNeuralNetwork.solve">
<code class="sig-name descname">solve</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#emepy.ann.MSNeuralNetwork.solve" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves for the eigenmode using the neural networks</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="emepy.ann.ANN">
<em class="property">class </em><code class="sig-prename descclassname">emepy.ann.</code><code class="sig-name descname">ANN</code><a class="headerlink" href="#emepy.ann.ANN" title="Permalink to this definition">¶</a></dt>
<dd><p>Object that loads the neural network; Users are heavily encouraged to design their own networks and rewrite their own ANN to match their needs</p>
<dl class="py method">
<dt id="emepy.ann.ANN.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#emepy.ann.ANN.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructor for Mode Object</p>
</dd></dl>

<dl class="py method">
<dt id="emepy.ann.ANN.Hx_network">
<code class="sig-name descname">Hx_network</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#emepy.ann.ANN.Hx_network" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the opened network model for the Hx component</p>
</dd></dl>

<dl class="py method">
<dt id="emepy.ann.ANN.Hy_network">
<code class="sig-name descname">Hy_network</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#emepy.ann.ANN.Hy_network" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the opened network model for the Hy component</p>
</dd></dl>

<dl class="py method">
<dt id="emepy.ann.ANN.neff_regression">
<code class="sig-name descname">neff_regression</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#emepy.ann.ANN.neff_regression" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the opened regression model for the effective index</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="emepy.ann.Network">
<em class="property">class </em><code class="sig-prename descclassname">emepy.ann.</code><code class="sig-name descname">Network</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">code_size</span></em>, <em class="sig-param"><span class="n">channels</span></em>, <em class="sig-param"><span class="n">component</span></em><span class="sig-paren">)</span><a class="headerlink" href="#emepy.ann.Network" title="Permalink to this definition">¶</a></dt>
<dd><p>The pytorch inherited class that defines and represents the physical neural network</p>
<dl class="py method">
<dt id="emepy.ann.Network.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">code_size</span></em>, <em class="sig-param"><span class="n">channels</span></em>, <em class="sig-param"><span class="n">component</span></em><span class="sig-paren">)</span><a class="headerlink" href="#emepy.ann.Network.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Network constructor</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>code_size</strong> (<em>int</em>) – the number of inputs</p></li>
<li><p><strong>channels</strong> (<em>int</em>) – the number of channels</p></li>
<li><p><strong>component</strong> (<em>string</em>) – “Hx” or “Hy”</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="emepy.ann.Network.forward">
<code class="sig-name descname">forward</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">field</span></em><span class="sig-paren">)</span><a class="headerlink" href="#emepy.ann.Network.forward" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs the network propagation</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>field</strong> (<em>array</em>) – The inputs to the network</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Returns a tuple of the outputs, inputs</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tuple (torch array, torch array)</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="tools">
<h2>Tools<a class="headerlink" href="#tools" title="Permalink to this headline">¶</a></h2>
<dl class="py function">
<dt id="emepy.tools.get_epsfunc">
<code class="sig-prename descclassname">emepy.tools.</code><code class="sig-name descname">get_epsfunc</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">width</span></em>, <em class="sig-param"><span class="n">thickness</span></em>, <em class="sig-param"><span class="n">cladding_width</span></em>, <em class="sig-param"><span class="n">cladding_thickness</span></em>, <em class="sig-param"><span class="n">core_index</span></em>, <em class="sig-param"><span class="n">cladding_index</span></em>, <em class="sig-param"><span class="n">compute</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">profile</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">nx</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">ny</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#emepy.tools.get_epsfunc" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the epsfunc for given parameters</p>
</dd></dl>

<dl class="py function">
<dt id="emepy.tools.Si">
<code class="sig-prename descclassname">emepy.tools.</code><code class="sig-name descname">Si</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">wavelength</span></em><span class="sig-paren">)</span><a class="headerlink" href="#emepy.tools.Si" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the refractive index for Silicon given the wavelength in microns.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>wavelength</strong> (<em>number</em>) – wavelength (microns)</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>refractive index</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>number</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="emepy.tools.SiO2">
<code class="sig-prename descclassname">emepy.tools.</code><code class="sig-name descname">SiO2</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">wavelength</span></em><span class="sig-paren">)</span><a class="headerlink" href="#emepy.tools.SiO2" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the refractive index for Silicon Dioxide given the wavelength in microns.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>wavelength</strong> (<em>number</em>) – the optical wavelength (microns)</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>refractive index</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>number</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="emepy.tools.into_chunks">
<code class="sig-prename descclassname">emepy.tools.</code><code class="sig-name descname">into_chunks</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">location</span></em>, <em class="sig-param"><span class="n">name</span></em>, <em class="sig-param"><span class="n">chunk_size</span><span class="o">=</span><span class="default_value">20000000</span></em><span class="sig-paren">)</span><a class="headerlink" href="#emepy.tools.into_chunks" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a large serialized file and breaks it up into smaller chunk files</p>
<dl class="simple">
<dt>location<span class="classifier">string</span></dt><dd><p>the absolute or relative path of the large file</p>
</dd>
<dt>name<span class="classifier">string</span></dt><dd><p>the name of the serialized smaller components (will have _chunk_# appended to it)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="emepy.tools.from_chunks">
<code class="sig-prename descclassname">emepy.tools.</code><code class="sig-name descname">from_chunks</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">location</span></em>, <em class="sig-param"><span class="n">name</span></em><span class="sig-paren">)</span><a class="headerlink" href="#emepy.tools.from_chunks" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a directory of serialized chunks that were made using into_chunks and combines them back into a large serialized file</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>location</strong> (<em>string</em>) – the path of the directory where the chunks are located</p></li>
<li><p><strong>name</strong> (<em>string</em>) – the name of the serialized file to create (make sure to include file extension if it matters)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="examples.html" class="btn btn-neutral float-right" title="EMEPy Examples" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="index.html" class="btn btn-neutral float-left" title="EMEpy" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2020, Ian Hammond

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>