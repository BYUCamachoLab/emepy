

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>EMEpy Complete User Library &mdash; EMEpy 2.0 documentation</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home" alt="Documentation Home"> EMEpy
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../library.html">EMEPy Complete User Library</a></li>
<li class="toctree-l1"><a class="reference internal" href="../examples.html">EMEPy Examples</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">EMEpy</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>EMEpy Complete User Library</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/old/class_func_old.md.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="emepy-complete-user-library">
<h1>EMEpy Complete User Library<a class="headerlink" href="#emepy-complete-user-library" title="Permalink to this headline">¶</a></h1>
<div class="section" id="tools">
<h2>Tools<a class="headerlink" href="#tools" title="Permalink to this headline">¶</a></h2>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">get_epsfunc</span><span class="p">(</span>
    <span class="n">width</span><span class="p">,</span> 
    <span class="n">thickness</span><span class="p">,</span> 
    <span class="n">cladding_width</span><span class="p">,</span> 
    <span class="n">cladding_thickness</span><span class="p">,</span> 
    <span class="n">core_index</span><span class="p">,</span> 
    <span class="n">cladding_index</span>
<span class="p">)</span>
</pre></div>
</div>
<ul class="simple">
<li><p><strong><code class="docutils literal notranslate"><span class="pre">width</span></code> [number]</strong> The width of the cross sectional core (m).</p></li>
<li><p><strong><code class="docutils literal notranslate"><span class="pre">thickness</span></code> [number]</strong> The thickness of the cross sectional core (m).</p></li>
<li><p><strong><code class="docutils literal notranslate"><span class="pre">cladding_width</span></code> [number]</strong> The width of the cross sectional cladding (m).</p></li>
<li><p><strong><code class="docutils literal notranslate"><span class="pre">cladding_thickness</span></code> [number]</strong> The thickness of the cross sectional cladding (m).</p></li>
<li><p><strong><code class="docutils literal notranslate"><span class="pre">core_index</span></code> [number]</strong> Index of refraction of the cross sectional core.</p></li>
<li><p><strong><code class="docutils literal notranslate"><span class="pre">cladding_index</span></code> [number]</strong> Index of refraction of the cross sectional cladding.</p></li>
</ul>
<p>The <code class="docutils literal notranslate"><span class="pre">get_epsfunc</span></code> function takes in a geometry and index of refraction for core and cladding of a simple rectangular waveguide and outputs another function. This new function can be used to extract the cross sectional square of the index of refraction for a given x,y space. This is only necessary for the EMpy modesolver, which is handled in the backend. Therefore users do not need to use this function, but can if they wish.</p>
<p><strong>Example</strong></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">emepy.tools</span> <span class="kn">import</span> <span class="n">get_epsfunc</span>
<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">pyplot</span> <span class="k">as</span> <span class="n">plt</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="n">index_func</span> <span class="o">=</span> <span class="n">get_epsfunc</span><span class="p">(</span>
    <span class="n">width</span> <span class="o">=</span> <span class="o">.</span><span class="mf">5e-6</span><span class="p">,</span> 
    <span class="n">thickness</span> <span class="o">=</span> <span class="o">.</span><span class="mf">22e-6</span><span class="p">,</span> 
    <span class="n">cladding_width</span> <span class="o">=</span> <span class="mf">5e-6</span><span class="p">,</span> 
    <span class="n">cladding_thickness</span> <span class="o">=</span> <span class="mf">5e-6</span><span class="p">,</span> 
    <span class="n">core_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">3.5</span><span class="p">),</span> 
    <span class="n">cladding_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">1.4</span><span class="p">)</span>
<span class="p">)</span>

<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">5e-6</span><span class="p">,</span> <span class="mi">128</span><span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">5e-6</span><span class="p">,</span> <span class="mi">128</span><span class="p">)</span>

<span class="n">index</span> <span class="o">=</span> <span class="n">index_func</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">index</span><span class="p">),</span><span class="n">extent</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;x (um)&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;y (um)&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;index&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p><img alt="old/images/eps_func.png" src="old/images/eps_func.png" /></p>
<hr class="docutils" />
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">Si</span><span class="p">(</span><span class="n">wavelength</span><span class="p">)</span>
</pre></div>
</div>
<ul class="simple">
<li><p><strong><code class="docutils literal notranslate"><span class="pre">wavelength</span></code> [number]</strong> The wavelength of light propagating through silicon (µm).</p></li>
</ul>
<p>The <code class="docutils literal notranslate"><span class="pre">Si</span></code> function provides an index of refraction in silicon given a specific wavelength. The function uses a regression on a dataset and is thus only valid for a range of wavelengths: (1.2µm - 14µm).</p>
<p><strong>Example</strong></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">emepy.tools</span> <span class="kn">import</span> <span class="n">Si</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="n">lambdas</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">1.5</span><span class="p">,</span><span class="mf">1.6</span><span class="p">,</span><span class="mi">10</span><span class="p">)</span>
<span class="n">index_array</span> <span class="o">=</span> <span class="p">[</span><span class="n">Si</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">lambdas</span><span class="p">]</span>

<span class="nb">print</span><span class="p">(</span><span class="n">index_array</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Output</strong></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="mf">3.4799</span><span class="p">,</span> <span class="mf">3.478966666666667</span><span class="p">,</span> <span class="mf">3.4780333333333333</span><span class="p">,</span> <span class="mf">3.4771</span><span class="p">,</span> <span class="mf">3.4761666666666664</span><span class="p">,</span> <span class="mf">3.4752777777777775</span><span class="p">,</span> <span class="mf">3.4744333333333333</span><span class="p">,</span> <span class="mf">3.473588888888889</span><span class="p">,</span> <span class="mf">3.4727444444444444</span><span class="p">,</span> <span class="mf">3.4719</span><span class="p">]</span>
</pre></div>
</div>
<hr class="docutils" />
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">SiO2</span><span class="p">(</span><span class="n">wavelength</span><span class="p">)</span>
</pre></div>
</div>
<ul class="simple">
<li><p><strong><code class="docutils literal notranslate"><span class="pre">wavelength</span></code> [number]</strong> The wavelength of light propagating through silicon dioxide (glass) (µm).</p></li>
</ul>
<p>The <code class="docutils literal notranslate"><span class="pre">SiO2</span></code> function provides an index of refraction in silicon given a specific wavelength. The function uses a regression on a dataset and is thus only valid for a range of wavelengths: (0.21µm - 6.7µm).</p>
<p><strong>Example</strong></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">emepy.tools</span> <span class="kn">import</span> <span class="n">SiO2</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="n">lambdas</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">1.5</span><span class="p">,</span><span class="mf">1.6</span><span class="p">,</span><span class="mi">10</span><span class="p">)</span>
<span class="n">index_array</span> <span class="o">=</span> <span class="p">[</span><span class="n">SiO2</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">lambdas</span><span class="p">]</span>

<span class="nb">print</span><span class="p">(</span><span class="n">index_array</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Output</strong></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="mf">1.4446167941939</span><span class="p">,</span> <span class="mf">1.4444864184114001</span><span class="p">,</span> <span class="mf">1.4443539800979162</span><span class="p">,</span> <span class="mf">1.444221362433912</span><span class="p">,</span> <span class="mf">1.4440887447699078</span><span class="p">,</span> <span class="mf">1.4439561271059036</span><span class="p">,</span> <span class="mf">1.4438231150141243</span><span class="p">,</span> <span class="mf">1.4436878678316192</span><span class="p">,</span> <span class="mf">1.4435526206491143</span><span class="p">,</span> <span class="mf">1.4434173734666091</span><span class="p">]</span>
</pre></div>
</div>
</div>
<div class="section" id="mode">
<h2>Mode<a class="headerlink" href="#mode" title="Permalink to this headline">¶</a></h2>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Mode</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">Mode</span></code> is a class that contains the information for an eigenmode. It stores Ex, Ey, Ez, Hx, Hy, Hz, and neff (the effective index).</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span> 
    <span class="n">x</span><span class="p">,</span> 
    <span class="n">y</span><span class="p">,</span> 
    <span class="n">wl</span><span class="p">,</span> 
    <span class="n">neff</span><span class="p">,</span> 
    <span class="n">Hx</span><span class="p">,</span> 
    <span class="n">Hy</span><span class="p">,</span> 
    <span class="n">Hz</span><span class="p">,</span> 
    <span class="n">Ex</span><span class="p">,</span> 
    <span class="n">Ey</span><span class="p">,</span> 
    <span class="n">Ez</span>
<span class="p">)</span>
</pre></div>
</div>
<ul class="simple">
<li><p><strong><code class="docutils literal notranslate"><span class="pre">x</span></code> [list [numbers]]</strong> List of positions in the x direction.</p></li>
<li><p><strong><code class="docutils literal notranslate"><span class="pre">y</span></code> [list [numbers]]</strong> List of positions in the y direction.</p></li>
<li><p><strong><code class="docutils literal notranslate"><span class="pre">wl</span></code> [number]</strong> Wavelength of eigenmode to solve for (m).</p></li>
<li><p><strong><code class="docutils literal notranslate"><span class="pre">neff</span></code> [number]</strong> Effective index of the eigenmode.</p></li>
<li><p><strong><code class="docutils literal notranslate"><span class="pre">Hx</span></code> [ndarray]</strong> len(x) x len(y) matrix representing the Hx field.</p></li>
<li><p><strong><code class="docutils literal notranslate"><span class="pre">Hy</span></code> [ndarray]</strong> len(x) x len(y) matrix representing the Hy field.</p></li>
<li><p><strong><code class="docutils literal notranslate"><span class="pre">Hz</span></code> [ndarray]</strong> len(x) x len(y) matrix representing the Hz field.</p></li>
<li><p><strong><code class="docutils literal notranslate"><span class="pre">Ex</span></code> [ndarray]</strong> len(x) x len(y) matrix representing the Ex field.</p></li>
<li><p><strong><code class="docutils literal notranslate"><span class="pre">Ey</span></code> [ndarray]</strong> len(x) x len(y) matrix representing the Ey field.</p></li>
<li><p><strong><code class="docutils literal notranslate"><span class="pre">Ez</span></code> [ndarray]</strong> len(x) x len(y) matrix representing the Ez field.</p></li>
</ul>
<p><strong>Methods</strong></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value_type</span><span class="o">=</span><span class="s2">&quot;Real&quot;</span><span class="p">,</span> <span class="n">colorbar</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
</pre></div>
</div>
<ul class="simple">
<li><p><strong><code class="docutils literal notranslate"><span class="pre">value_type</span> </code> [string]</strong> Operation of field to look at. Options: ‘Real’, ‘Imaginary’, ‘Abs’, ‘Abs^2’. [default: ‘Real’]</p></li>
<li><p><strong><code class="docutils literal notranslate"><span class="pre">colorbar</span></code> [bool]</strong> If True, includes a colorbar on each subplot. [default: True]</p></li>
</ul>
<p>Plots all 6 fields into subplots with pyplot.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">inner_product</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mode2</span><span class="p">):</span>
</pre></div>
</div>
<ul class="simple">
<li><p><strong><code class="docutils literal notranslate"><span class="pre">mode2</span> </code> [Mode]</strong> A second mode to overlap with.</p></li>
</ul>
<p>Takes the inner product (overlap) with another mode. If both fields are normalized to power 1, then an overlap of 1 means perfect overlap and an overlap of 0 means no overlap.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">normalize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</pre></div>
</div>
<p>Normalizes the Mode to power 1.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">zero_phase</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</pre></div>
</div>
<p>Changes the phase such that the z components are all imaginary and the xy components are all real.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">get_fields</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</pre></div>
</div>
<p>Returns an array [self.Hx, self.Hy, self.Hz, self.Ex, self.Ey, self.Ez].</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">get_H</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</pre></div>
</div>
<p>Returns an array [self.Hx, self.Hy, self.Hz].</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">get_E</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</pre></div>
</div>
<p>Returns an array [self.Ex, self.Ey, self.Ez].</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">get_neff</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</pre></div>
</div>
<p>Returns the effective index as a complex number.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">get_wavelength</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</pre></div>
</div>
<p>Returns the wavelength.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">save</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
</pre></div>
</div>
<ul class="simple">
<li><p><strong><code class="docutils literal notranslate"><span class="pre">path</span></code> [string]</strong> The path (including name) to save the file. [default: “./ModeObject_” + str(random.random())]</p></li>
</ul>
<p>Saves the <code class="docutils literal notranslate"><span class="pre">Mode</span></code> object into a pickled file. Can be reloaded using the <code class="docutils literal notranslate"><span class="pre">ModeSolver_Pickle</span></code> class.</p>
<p><strong>Example</strong></p>
</div>
<div class="section" id="modesolvers">
<h2>ModeSolvers<a class="headerlink" href="#modesolvers" title="Permalink to this headline">¶</a></h2>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ModeSolver_EMpy</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">ModeSolver_EMpy</span></code> is based on the electromagnetic python module. It’s open-source and fairly easy to use. This is the recommended class for users who want to use a finite difference solver.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">wl</span><span class="p">,</span>
    <span class="n">width</span><span class="p">,</span>
    <span class="n">thickness</span><span class="p">,</span>
    <span class="n">num_modes</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">cladding_width</span><span class="o">=</span><span class="mf">2.5e-6</span><span class="p">,</span>
    <span class="n">cladding_thickness</span><span class="o">=</span><span class="mf">2.5e-6</span><span class="p">,</span>
    <span class="n">core_index</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">cladding_index</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">x</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">mesh</span><span class="o">=</span><span class="mi">300</span><span class="p">,</span>
    <span class="n">accuracy</span><span class="o">=</span><span class="mf">1e-8</span><span class="p">,</span>
    <span class="n">boundary</span><span class="o">=</span><span class="s2">&quot;0000&quot;</span><span class="p">,</span>
    <span class="n">epsfunc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="p">)</span>
</pre></div>
</div>
<ul class="simple">
<li><p><strong><code class="docutils literal notranslate"><span class="pre">wl</span></code> [number]</strong> Wavelength of eigenmode to solve for (m).</p></li>
<li><p><strong><code class="docutils literal notranslate"><span class="pre">width</span></code> [number]</strong> Width of the core in the rectangular cross section (m).</p></li>
<li><p><strong><code class="docutils literal notranslate"><span class="pre">thickness</span></code> [number]</strong> Thickness of the core in the rectangular cross section (m).</p></li>
<li><p><strong><code class="docutils literal notranslate"><span class="pre">num_modes</span></code> [int]</strong> Number of modes to solve for. [default: 1]</p></li>
<li><p><strong><code class="docutils literal notranslate"><span class="pre">cladding_width</span></code> [number]</strong> Width of the cladding in the rectangular cross section (m). [default: 2.5e-6]</p></li>
<li><p><strong><code class="docutils literal notranslate"><span class="pre">cladding_thickness</span></code> [number]</strong> Thickness of the cladding in the rectangular cross section (m). [default: 2.5e-6]</p></li>
<li><p><strong><code class="docutils literal notranslate"><span class="pre">core_index</span></code> [number]</strong> Index of refraction of the cross sectional core. [default: Si(wl*1e6)]</p></li>
<li><p><strong><code class="docutils literal notranslate"><span class="pre">cladding_index</span></code> [number]</strong> Index of refraction of the cross sectional cladding. [default: SiO2(wl*1e6)]</p></li>
<li><p><strong><code class="docutils literal notranslate"><span class="pre">x</span></code> [list [numbers]]</strong> List of positions in the x direction. [default: np.linspace(0,cladding_width,mesh)]</p></li>
<li><p><strong><code class="docutils literal notranslate"><span class="pre">y</span></code> [list [numbers]]</strong> List of positions in the y direction. [default: np.linspace(0,cladding_thickess,mesh)]</p></li>
<li><p><strong><code class="docutils literal notranslate"><span class="pre">mesh</span></code> [int]</strong> If provided, provides an equally spaced x,y grid with <code class="docutils literal notranslate"><span class="pre">mesh</span></code> number of points.  [default: 300]</p></li>
<li><p><strong><code class="docutils literal notranslate"><span class="pre">accuracy</span></code> [number]</strong> Accuracy of the EMpy solver, smaller <code class="docutils literal notranslate"><span class="pre">accuracy</span></code> is more accurate. [default: 1e-8]</p></li>
<li><p><strong><code class="docutils literal notranslate"><span class="pre">boundary</span></code> [string]</strong> EMpy boundary type “NESW”. Users should only change if they’ve read the EMpy documentation for boundaries. [default: “0000”]</p></li>
<li><p><strong><code class="docutils literal notranslate"><span class="pre">epsfunc</span></code> [function]</strong> Function that provides a mapping of the index of refraction based on a given grid. See <code class="docutils literal notranslate"><span class="pre">get_epsfunc</span></code>. [default: get_epsfunc(width, thickness, cladding_width, cladding_thickness, core_index, cladding_index)]</p></li>
</ul>
<p><strong>Methods</strong></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</pre></div>
</div>
<p>Calls the <code class="docutils literal notranslate"><span class="pre">ModeSolver</span></code> to actually solve for the modes.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">clear</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</pre></div>
</div>
<p>Clear the modes inside the <code class="docutils literal notranslate"><span class="pre">ModeSolver</span></code> to open memory.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">get_mode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mode_num</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
</pre></div>
</div>
<p>Get the nth order <code class="docutils literal notranslate"><span class="pre">Mode</span></code> given by mode_num.</p>
<ul class="simple">
<li><p><strong><code class="docutils literal notranslate"><span class="pre">mode_num</span></code> [int]</strong> The index of the nth order <code class="docutils literal notranslate"><span class="pre">Mode</span></code> to get.</p></li>
</ul>
<p><strong>Example</strong></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">emepy.FD_modesolvers</span> <span class="kn">import</span> <span class="n">ModeSolver_EMpy</span>
<span class="kn">from</span> <span class="nn">emepy.mode</span> <span class="kn">import</span> <span class="n">Mode</span>
<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">pyplot</span> <span class="k">as</span> <span class="n">plt</span>

<span class="n">modesolver</span> <span class="o">=</span> <span class="n">ModeSolver_EMpy</span><span class="p">(</span>
    <span class="n">wl</span><span class="o">=</span><span class="mf">1.55e-6</span><span class="p">,</span>
    <span class="n">width</span><span class="o">=.</span><span class="mf">5e-6</span><span class="p">,</span>
    <span class="n">thickness</span><span class="o">=.</span><span class="mf">22e-6</span><span class="p">,</span>
    <span class="n">mesh</span> <span class="o">=</span> <span class="mi">128</span>
<span class="p">)</span>

<span class="n">modesolver</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
<span class="n">mode</span> <span class="o">=</span> <span class="n">modesolver</span><span class="o">.</span><span class="n">get_mode</span><span class="p">()</span>

<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="n">mode</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p><img alt="old/images/plot_mode.png" src="old/images/plot_mode.png" /></p>
<hr class="docutils" />
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ModeSolver_Lumerical</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
</pre></div>
</div>
<p>ModeSolver_Lumerical requires the Lumerical API. Licensing for such is not free. Therefore users are encouraged to use the other classes which work just as well.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">wl</span><span class="p">,</span>
    <span class="n">width</span><span class="p">,</span>
    <span class="n">thickness</span><span class="p">,</span>
    <span class="n">num_modes</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">cladding_width</span><span class="o">=</span><span class="mf">5e-6</span><span class="p">,</span>
    <span class="n">cladding_thickness</span><span class="o">=</span><span class="mf">5e-6</span><span class="p">,</span>
    <span class="n">core_index</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">cladding_index</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">mesh</span><span class="o">=</span><span class="mi">300</span><span class="p">,</span>
    <span class="n">lumapi_location</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="p">)</span>
</pre></div>
</div>
<ul class="simple">
<li><p><strong><code class="docutils literal notranslate"><span class="pre">wl</span></code> [number]</strong> Wavelength of eigenmode to solve for (m).</p></li>
<li><p><strong><code class="docutils literal notranslate"><span class="pre">width</span></code> [number]</strong> Width of the core in the rectangular cross section (m).</p></li>
<li><p><strong><code class="docutils literal notranslate"><span class="pre">thickness</span></code> [number]</strong> Thickness of the core in the rectangular cross section (m).</p></li>
<li><p><strong><code class="docutils literal notranslate"><span class="pre">num_modes</span></code> [int]</strong> Number of modes to solve for. [default: 1]</p></li>
<li><p><strong><code class="docutils literal notranslate"><span class="pre">cladding_width</span></code> [number]</strong> Width of the cladding in the rectangular cross section (m). [default: 2.5e-6]</p></li>
<li><p><strong><code class="docutils literal notranslate"><span class="pre">cladding_thickness</span></code> [number]</strong> Thickness of the cladding in the rectangular cross section (m). [default: 2.5e-6]</p></li>
<li><p><strong><code class="docutils literal notranslate"><span class="pre">core_index</span></code> [number]</strong> Index of refraction of the cross sectional core. [default: Si(wl*1e6)]</p></li>
<li><p><strong><code class="docutils literal notranslate"><span class="pre">cladding_index</span></code> [number]</strong> Index of refraction of the cross sectional cladding. [default: SiO2(wl*1e6)]</p></li>
<li><p><strong><code class="docutils literal notranslate"><span class="pre">mesh</span></code> [int]</strong> If provided, provides an equally spaced x,y grid with <code class="docutils literal notranslate"><span class="pre">mesh</span></code> number of points.  [default: 300]</p></li>
<li><p><strong><code class="docutils literal notranslate"><span class="pre">lumapi_location</span></code> [string]</strong> If the Lumerical Python API is not already in the user’s path, they may add the path here. [default: None]. Ubuntu example: “/opt/lumerical/v202/api/python” .</p></li>
</ul>
<p><strong>Methods</strong></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</pre></div>
</div>
<p>Calls the <code class="docutils literal notranslate"><span class="pre">ModeSolver</span></code> to actually solve for the modes.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">clear</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</pre></div>
</div>
<p>Clear the modes inside the <code class="docutils literal notranslate"><span class="pre">ModeSolver</span></code> to open memory.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">get_mode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mode_num</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
</pre></div>
</div>
<p>Get the nth order <code class="docutils literal notranslate"><span class="pre">Mode</span></code> given by mode_num.</p>
<ul class="simple">
<li><p><strong><code class="docutils literal notranslate"><span class="pre">mode_num</span></code> [int]</strong> The index of the nth order <code class="docutils literal notranslate"><span class="pre">Mode</span></code> to get.</p></li>
</ul>
<p><strong>Example</strong></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">emepy.FD_modesolvers</span> <span class="kn">import</span> <span class="n">ModeSolver_Lumerical</span>
<span class="kn">from</span> <span class="nn">emepy.mode</span> <span class="kn">import</span> <span class="n">Mode</span>
<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">pyplot</span> <span class="k">as</span> <span class="n">plt</span>

<span class="n">modesolver</span> <span class="o">=</span> <span class="n">ModeSolver_Lumerical</span><span class="p">(</span>
    <span class="n">wl</span><span class="o">=</span><span class="mf">1.55e-6</span><span class="p">,</span>
    <span class="n">width</span><span class="o">=.</span><span class="mf">5e-6</span><span class="p">,</span>
    <span class="n">thickness</span><span class="o">=.</span><span class="mf">22e-6</span><span class="p">,</span>
    <span class="n">mesh</span> <span class="o">=</span> <span class="mi">128</span><span class="p">,</span>
    <span class="n">lumapi_location</span> <span class="o">=</span> <span class="s2">&quot;/opt/lumerical/v202/api/python&quot;</span>
<span class="p">)</span>

<span class="n">modesolver</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
<span class="n">mode</span> <span class="o">=</span> <span class="n">modesolver</span><span class="o">.</span><span class="n">get_mode</span><span class="p">()</span>

<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="n">mode</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">value_type</span><span class="o">=</span><span class="s2">&quot;abs^2&quot;</span><span class="p">,</span> <span class="n">colorbar</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p><img alt="old/images/plot_lumapi.png" src="old/images/plot_lumapi.png" /></p>
<hr class="docutils" />
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ModeSolver_Pickle</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
</pre></div>
</div>
<p>ModeSolver_Pickle simply uses the pickle library to open files with presaved field profiles and effective indices. This requires no mode solving during the EME process, however requires saved fields beforehand.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span> 
    <span class="n">filename</span><span class="p">,</span> 
    <span class="n">index</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
    <span class="n">width</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
    <span class="n">thickness</span><span class="o">=</span><span class="kc">None</span>
<span class="p">)</span>
</pre></div>
</div>
<ul class="simple">
<li><p><strong><code class="docutils literal notranslate"><span class="pre">filename</span></code> [string]</strong> Location of where the pickled file is located.</p></li>
<li><p><strong><code class="docutils literal notranslate"><span class="pre">index</span></code> [int]</strong> If the pickle file has an list of Modes saved as opposed to the default singular Mode saved, provide an index of the list for which Mode the user wants.</p></li>
<li><p><strong><code class="docutils literal notranslate"><span class="pre">width</span></code> [number]</strong> Width of the core in the rectangular cross section (m). Only used for drawing EME geometry. Optional.</p></li>
<li><p><strong><code class="docutils literal notranslate"><span class="pre">thickness</span></code> [number]</strong> Thickness of the core in the rectangular cross section (m). Only used for drawing EME geometry. Optional.</p></li>
</ul>
<p><strong>Methods</strong></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</pre></div>
</div>
<p>Calls the <code class="docutils literal notranslate"><span class="pre">ModeSolver</span></code> to actually solve for the modes.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">clear</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</pre></div>
</div>
<p>Clear the modes inside the <code class="docutils literal notranslate"><span class="pre">ModeSolver</span></code> to open memory.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">get_mode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mode_num</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
</pre></div>
</div>
<p>Get the nth order <code class="docutils literal notranslate"><span class="pre">Mode</span></code> given by mode_num.</p>
<ul class="simple">
<li><p><strong><code class="docutils literal notranslate"><span class="pre">mode_num</span></code> [int]</strong> The index of the nth order <code class="docutils literal notranslate"><span class="pre">Mode</span></code> to get.</p></li>
</ul>
<p><strong>Example</strong></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">emepy.FD_modesolvers</span> <span class="kn">import</span> <span class="n">ModeSolver_EMpy</span>
<span class="kn">from</span> <span class="nn">emepy.FD_modesolvers</span> <span class="kn">import</span> <span class="n">ModeSolver_Pickle</span>
<span class="kn">from</span> <span class="nn">emepy.mode</span> <span class="kn">import</span> <span class="n">Mode</span>
<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">pyplot</span> <span class="k">as</span> <span class="n">plt</span>
<span class="kn">import</span> <span class="nn">pickle</span> <span class="k">as</span> <span class="nn">pk</span>

<span class="n">modesolver</span> <span class="o">=</span> <span class="n">ModeSolver_EMpy</span><span class="p">(</span><span class="n">wl</span><span class="o">=</span><span class="mf">1.55e-6</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mf">0.5e-6</span><span class="p">,</span> <span class="n">thickness</span><span class="o">=</span><span class="mf">0.22e-6</span><span class="p">,</span> <span class="n">mesh</span><span class="o">=</span><span class="mi">128</span><span class="p">)</span>
<span class="n">modesolver</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
<span class="n">mode</span> <span class="o">=</span> <span class="n">modesolver</span><span class="o">.</span><span class="n">get_mode</span><span class="p">()</span>
<span class="n">pk</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="nb">open</span><span class="p">(</span><span class="s2">&quot;./example_file.pk&quot;</span><span class="p">,</span> <span class="s2">&quot;wb+&quot;</span><span class="p">))</span>

<span class="c1"># Separate instance</span>

<span class="n">modesolver</span> <span class="o">=</span> <span class="n">ModeSolver_Pickle</span><span class="p">(</span><span class="n">filename</span><span class="o">=</span><span class="s2">&quot;./example_file.pk&quot;</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mf">0.5e-6</span><span class="p">,</span> <span class="n">thickness</span><span class="o">=</span><span class="mf">0.22e-6</span><span class="p">)</span>

<span class="n">modesolver</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
<span class="n">mode</span> <span class="o">=</span> <span class="n">modesolver</span><span class="o">.</span><span class="n">get_mode</span><span class="p">()</span>

<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="n">mode</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">value_type</span><span class="o">=</span><span class="s2">&quot;Imaginary&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p><img alt="old/images/plot_pickle.png" src="old/images/plot_pickle.png" /></p>
<hr class="docutils" />
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ModeSolver_ANN</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
</pre></div>
</div>
<p>ModeSolver_ANN is an example class for what users may design if they chose to use neural networks to generate modes. This is computationally the fasted of the solvers themselves, but requires a pretrained network. **Currently being finished, users should use the other ModeSolvers for now. **</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">wavelength</span><span class="p">,</span>
    <span class="n">width</span><span class="p">,</span>
    <span class="n">thickness</span><span class="p">,</span>
    <span class="n">sklearn_save</span><span class="p">,</span>
    <span class="n">torch_save_x</span><span class="p">,</span>
    <span class="n">torch_save_y</span><span class="p">,</span>
    <span class="n">num_modes</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">cladding_width</span><span class="o">=</span><span class="mf">5e-6</span><span class="p">,</span>
    <span class="n">cladding_thickness</span><span class="o">=</span><span class="mf">5e-6</span><span class="p">,</span>
    <span class="n">x</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="p">)</span>
</pre></div>
</div>
<ul class="simple">
<li><p><strong><code class="docutils literal notranslate"><span class="pre">wl</span></code> [number]</strong> Wavelength of eigenmode to solve for (m).</p></li>
<li><p><strong><code class="docutils literal notranslate"><span class="pre">width</span></code> [number]</strong> Width of the core in the rectangular cross section (m).</p></li>
<li><p><strong><code class="docutils literal notranslate"><span class="pre">thickness</span></code> [number]</strong> Thickness of the core in the rectangular cross section (m).</p></li>
<li><p><strong><code class="docutils literal notranslate"><span class="pre">sklearn_save</span></code> [string]</strong> Sklearn save location for the effective index polynomial regression. [default: ?]</p></li>
<li><p><strong><code class="docutils literal notranslate"><span class="pre">torch_save_x</span></code> [string]</strong> Pytorch save location for the Hx field neural network. [default: ?]</p></li>
<li><p><strong><code class="docutils literal notranslate"><span class="pre">torch_save_y</span></code> [string]</strong> Pytorch save location for the HY field neural network. [default: ?]</p></li>
<li><p><strong><code class="docutils literal notranslate"><span class="pre">num_modes</span></code> [int]</strong> Number of modes to solve for. (Don’t change for this specific set of networks.) [default: 1]</p></li>
<li><p><strong><code class="docutils literal notranslate"><span class="pre">cladding_width</span></code> [number]</strong> Width of the cladding in the rectangular cross section (m). (Don’t change for this specific set of networks.) [default: 2.5e-6]</p></li>
<li><p><strong><code class="docutils literal notranslate"><span class="pre">cladding_thickness</span></code> [number]</strong> Thickness of the cladding in the rectangular cross section (m). (Don’t change for this specific set of networks.) [default: 2.5e-6]</p></li>
<li><p><strong><code class="docutils literal notranslate"><span class="pre">x</span></code> [list [numbers]]</strong> List of positions in the x direction. [default: np.linspace(0,cladding_width,mesh)]</p></li>
<li><p><strong><code class="docutils literal notranslate"><span class="pre">y</span></code> [list [numbers]]</strong> List of positions in the y direction. [default: np.linspace(0,cladding_thickess,mesh)]</p></li>
</ul>
<p><strong>Methods</strong></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</pre></div>
</div>
<p>Calls the <code class="docutils literal notranslate"><span class="pre">ModeSolver</span></code> to actually solve for the modes.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">clear</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</pre></div>
</div>
<p>Clear the modes inside the <code class="docutils literal notranslate"><span class="pre">ModeSolver</span></code> to open memory.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">get_mode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mode_num</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
</pre></div>
</div>
<p>Get the nth order <code class="docutils literal notranslate"><span class="pre">Mode</span></code> given by mode_num.</p>
<ul class="simple">
<li><p><strong><code class="docutils literal notranslate"><span class="pre">mode_num</span></code> [int]</strong> The index of the nth order <code class="docutils literal notranslate"><span class="pre">Mode</span></code> to get.</p></li>
</ul>
<p><strong>Example</strong></p>
</div>
<div class="section" id="eme-simulation">
<h2>EME Simulation<a class="headerlink" href="#eme-simulation" title="Permalink to this headline">¶</a></h2>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">EME</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">EME</span></code> class is the heart of the package. It provides the algorithm that cascades sections modes together to provide the s-parameters for a geometric structure. The object is dependent on the <code class="docutils literal notranslate"><span class="pre">Layer</span></code> objects that are fed inside.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span> 
    <span class="n">layers</span><span class="o">=</span><span class="p">[],</span>
    <span class="n">keep_modeset</span><span class="o">=</span><span class="kc">False</span>
<span class="p">)</span>
</pre></div>
</div>
<ul class="simple">
<li><p><strong><code class="docutils literal notranslate"><span class="pre">layers</span></code> [list [<code class="docutils literal notranslate"><span class="pre">Layer</span></code>]]</strong> An list of Layer objects, arranged in the order they belong geometrically. [default: []]</p></li>
<li><p><strong><code class="docutils literal notranslate"><span class="pre">keep_modeset</span></code> [bool]</strong> If true, will keep the first and last layers’ modes in the system after the simulation is complete. This is utilized by the <code class="docutils literal notranslate"><span class="pre">PeriodicEME</span></code> object. It can also be used by users who wish to examine the first of last modes after the simulation is complete, but usually this is kept false. [default: False].</p></li>
</ul>
<p><strong>Methods</strong></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">add_layer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">layer</span><span class="p">):</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">add_layer</span></code> method will add a <code class="docutils literal notranslate"><span class="pre">Layer</span></code> object to the <code class="docutils literal notranslate"><span class="pre">EME</span></code> object. The object will be geometrically added to the very right side of the structure. Using this method after <code class="docutils literal notranslate"><span class="pre">propagate</span></code> is useless as the solver has already been called.</p>
<ul>
<li><p><strong><code class="docutils literal notranslate"><span class="pre">layer</span></code> [<code class="docutils literal notranslate"><span class="pre">Layer</span></code>]</strong> <code class="docutils literal notranslate"><span class="pre">Layer</span></code> object to be appended to the list of <code class="docutils literal notranslate"><span class="pre">Layers</span></code> inside the EME object.</p>
<p>def propagate(self):</p>
</li>
</ul>
<p>The <code class="docutils literal notranslate"><span class="pre">propagate</span></code> method should be called once all <code class="docutils literal notranslate"><span class="pre">Layer</span></code> objects have been added. This method will call the <code class="docutils literal notranslate"><span class="pre">EME</span></code> solver and produce s-parameters.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">s_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">s_parameters</span></code> method returns an MxN numpy array of s-parameters where each index representing the transmission/reflection from mode N to mode M. M = Number of output modes on the right + Number of output modes on the left. M = Number of input modes on the right + Number of input modes on the left. For each, the order of modes as they correspond to the port number are the left modes from most fundamental to least, and then the right modes.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">draw</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">draw</span></code> method sketches a rough approximation for the xz geometry of the structure using pyplot where x is the width of the structure and z is the length.</p>
<p><strong>Example</strong></p>
<hr class="docutils" />
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">PeriodicEME</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">PeriodicEME</span></code> class works similarly to the <code class="docutils literal notranslate"><span class="pre">EME</span></code> class. Users specificy the number of periods of repeated geometry and the solving process will significatnly decrease in time when compared to running a full simulation using <code class="docutils literal notranslate"><span class="pre">EME</span></code>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span> 
    <span class="n">layers</span><span class="o">=</span><span class="p">[],</span> 
    <span class="n">num_periods</span><span class="o">=</span><span class="mi">1</span>
<span class="p">)</span>
</pre></div>
</div>
<ul class="simple">
<li><p><strong><code class="docutils literal notranslate"><span class="pre">layers</span></code> [list [<code class="docutils literal notranslate"><span class="pre">Layer</span></code>]]</strong> An list of Layer objects, arranged in the order they belong geometrically. [default: []]</p></li>
<li><p><strong><code class="docutils literal notranslate"><span class="pre">num_periods</span></code> [int]</strong> Number of periods in the repeated geometry. If num_periods == 1, <code class="docutils literal notranslate"><span class="pre">PeriodicEME</span></code> becomes the same as <code class="docutils literal notranslate"><span class="pre">EME</span></code>. [default: 1]</p></li>
</ul>
<p><strong>Methods</strong></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">add_layer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">layer</span><span class="p">):</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">add_layer</span></code> method will add a <code class="docutils literal notranslate"><span class="pre">Layer</span></code> object to the <code class="docutils literal notranslate"><span class="pre">EME</span></code> object. The object will be geometrically added to the very right side of the structure. Using this method after <code class="docutils literal notranslate"><span class="pre">propagate</span></code> is useless as the solver has already been called.</p>
<ul>
<li><p><strong><code class="docutils literal notranslate"><span class="pre">layer</span></code> [<code class="docutils literal notranslate"><span class="pre">Layer</span></code>]</strong> <code class="docutils literal notranslate"><span class="pre">Layer</span></code> object to be appended to the list of <code class="docutils literal notranslate"><span class="pre">Layers</span></code> inside the EME object.</p>
<p>def propagate(self):</p>
</li>
</ul>
<p>The <code class="docutils literal notranslate"><span class="pre">propagate</span></code> method should be called once all <code class="docutils literal notranslate"><span class="pre">Layer</span></code> objects have been added. This method will call the <code class="docutils literal notranslate"><span class="pre">EME</span></code> solver and produce s-parameters.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">s_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">s_parameters</span></code> method returns an MxN numpy array of s-parameters where each index representing the transmission/reflection from mode N to mode M. M = Number of output modes on the right + Number of output modes on the left. M = Number of input modes on the right + Number of input modes on the left. For each, the order of modes as they correspond to the port number are the left modes from most fundamental to least, and then the right modes.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">draw</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">draw</span></code> method sketches a rough approximation for the xz geometry of the structure using pyplot where x is the width of the structure and z is the length.</p>
<p><strong>Example</strong></p>
<hr class="docutils" />
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Layer</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">Layer</span></code> objects form the building blocks inside of an <code class="docutils literal notranslate"><span class="pre">EME</span></code> or <code class="docutils literal notranslate"><span class="pre">PeriodicEME</span></code>. These represent geometric layers of rectangular waveguides that approximate continuous structures.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span> 
    <span class="n">mode_solvers</span><span class="p">,</span> 
    <span class="n">num_modes</span><span class="p">,</span> 
    <span class="n">wavelength</span><span class="p">,</span> 
    <span class="n">length</span>
<span class="p">)</span>   
</pre></div>
</div>
<ul class="simple">
<li><p><strong><code class="docutils literal notranslate"><span class="pre">mode_solvers</span></code> [list [<code class="docutils literal notranslate"><span class="pre">Modesolver</span></code>] or <code class="docutils literal notranslate"><span class="pre">Modesolver</span></code>]</strong> List of <code class="docutils literal notranslate"><span class="pre">Modesolver</span></code> objects. Should be in order from fundamental mode to least significant mode. If singular <code class="docutils literal notranslate"><span class="pre">Modesolver</span></code>, can leave alone without a list.</p></li>
<li><p><strong><code class="docutils literal notranslate"><span class="pre">num_modes</span></code> [int]</strong> Number of total modes for the layer.</p></li>
<li><p><strong><code class="docutils literal notranslate"><span class="pre">wavelength</span></code> [number]</strong> Wavelength of eigenmode to solve for (m).</p></li>
<li><p><strong><code class="docutils literal notranslate"><span class="pre">length</span></code> [number]</strong> Geometric length of the Layer (m). The length affects the phase of the eigenmodes inside the layer via the complex phasor $e^(jβz)$.</p></li>
</ul>
<p><strong>Example</strong></p>
<hr class="docutils" />
</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2020, Ian Hammond

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>